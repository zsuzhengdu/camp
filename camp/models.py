# models.py
from django.db import models
from django.contrib.auth.models import User
from django.db.models.signals import post_save
from account.models import Account


import settings

class Person(models.Model):
    name = models.CharField(max_length=80)
    birthday = models.DateField(auto_now=True, auto_now_add=True)
    def __unicode__(self):
        return u"%s was born in %s" % (self.name, self.birthday.strftime("%B of %Y"))
    def as_dict(self):
        return {'name':self.name, 'birthday':self.birthday.strftime("%B of %Y")}




class Video(models.Model):
	videoname = models.CharField(max_length=100)					# name of video
	videostate = models.CharField(max_length=10)					# Current state of video "uploaded --> in process ->  
															#  --> Done.
	videopath = models.FileField(upload_to="videos", max_length=100)
	#videopath = ContentTypeRestrictedFileField(content_types=['video/flv', 'video/mp4',],max_upload_size=5242880,blank=True, null=True)
	
	videosource = models.CharField(max_length=256)
	videourl = models.CharField(max_length=256)
	videolength = models.IntegerField()
	videobid = models.FloatField(default =0)		# $ customer would like to pay
 	upload_date = models.DateTimeField(auto_now_add=True)					# Upload date
	language = models.CharField(max_length=128)
	note = models.TextField()



	# transcriber = models.CharField(max_length=100)			# Track Transcriber's name
	# qa = models.CharField(max_length=100)					# Track QA's name
	

	# length = models.IntegerField()							# length of video
	# exp_days = models.IntegerField()						# exp_days
	
	# sugg_price = models.FloatField()						# suggested price, basing on exp_days & length of video
															# Could be .js code to calculate the suggested price on the webpage

	# bid = models.FloatField()								# customer offered price, got 10% when task expires.  
	# portion = models.FloatField()	
	# created_at = models.DateTimeField(auto_now_add=True)	# Calculating the monthly payment to worker,
	
	transcription = models.TextField()					# sub got from transcriber
	verification = models.TextField()								# sub got after verification
	
	#format = models.CharField(max_length=100)				# Format of video .srt 
	
	# Watch of the unicode issue of TextField() with DB

	####					
			# A class method is needed  to check the difference of the subs generated by QA and Transcriber
			# def _check_diff(self, **kwargs):
	####

	def __unicode__(self):
		return u'%s - %s' % (self.videoname, self.videostate) 


class Customer(models.Model):
	account = models.OneToOneField(Account, verbose_name=("customer"))
	videos = models.ManyToManyField(Video, blank=True)		# videos uploaded by customer
	fund = models.FloatField(default =0)								# fund availdable (in String), right now customer pay by usage
	
	def __unicode__(self):
		return self.account.user.username


class Worker(models.Model):
	account = models.OneToOneField(Account, verbose_name=("worker"))
	videos = models.ManyToManyField(Video, blank=True)		# videos transcribed/verified by worker
	
	# earned = models.CharField(max_length=100)				# fund earned by worker
	# At the end of each month, periodically calcualte the salary earned by worker (Class method excuted by Celery at the 
	# end of month by checking the 'state of vidoe' and 

	level = models.IntegerField(null=True, blank=True)						# level that qualified worker
	state = models.CharField(max_length=10)					# Current state of video  "idle --> busy --> idle"
	total_earned = models.FloatField(default=0)
	

	def __unicode__(self):
		return self.account.user.username


from paypal.standard.ipn.signals import payment_was_successful

def show_me_the_money(sender, **kwargs):
	print	"----> show me the money" 
	print	'*' * 20
	print 	kwargs
	print 	'*' * 20


payment_was_successful.connect(show_me_the_money)

"""
from django.dispatch import Signal

# The Signal object (think of it as an exchange)
log_it = Signal(providing_args=['level', 'message'])

# These functions are receivers (subscribers). They will receive 
# the signal (message) sent (published) by the sender (publisher).
def simple_receiver(**kwargs):
    message, level = kwargs['message'], kwargs['level']
    print 'Receiver # 1'
    print '\tLevel: %d, Message: %s\n' % (level, message)

def picky_receiver(**kwargs):
    message, level = kwargs['message'], kwargs['level']
    print 'Receiver # 2'
    if level < 2:
        print "\tSome unimportant message was sent. Ignoring it!\n"

# Okay, now time to connect these receivers to the log_it signal object.
log_it.connect(simple_receiver)
log_it.connect(picky_receiver)

# The sender (publisher) that sends (publishes) a signal (message).
# This message will received by all connected (subscribed)
# receivers (subscribers).
def a_cool_sender():
    # Do something cool here
    # Now send a signal to all receivers
    log_it.send(sender='a_cool_sender', message='Hello!', level=1)

"""

